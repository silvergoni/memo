---
title: "spring"
date: 2019-07-02 14:55:28 -0400
categories: java
---

### Spring init
출처 : http://wonwoo.ml/index.php/post/1590
- 이전 : web.xml < DispatcherServlet 등록
- 지금 : WebApplicationInitializer에서 onStartup 메서드 구현
- 더편하게 : AbstractAnnotationConfigDispatcherServletInitializer 클래스 구현


## Locale
출처 : https://javaslave.tistory.com/69
BaseLocale 특징
  - hash 를 씀
    - getInstance
  - cache 도 씀
    - normalize와 intern을 쓴 이유가 뭘까

Locale
  - request.getLocale()은 org.apache.catalina.connector 패키지의 Requset.getLocale 에서 가져온다.
  - Header에서 "accept-language"에 있는 value값을 파싱하여 가장 첫번째값으 보여주는 로직이 있다.
  - http://www.docjar.com/html/api/org/apache/catalina/connector/Request.java.html
LocaleResolver는 header, session, cookie에서 파싱해서 처리한다.

### MessageSource
MessageSource 구현체는 총 3개가 있다.
- org.springframework.context.support.ResourceBundleMessageSource
  - 특정이름으로 번들을 호출할 수 있따?
  - ResourceBundle 클래스와 MessageFormat클래스 기반으로 만들어 졌으며, 번들에 특정 이름으로 접근가능.

- org.springframework.context.support.ReloadableResourceBundleMessageSource
  - 캐쉬를 주어 몇초마다 리로드가 가능하다.
  - 부가적으로 인코딩도 세팅가능

- org.springframework.context.support.StaticMessageSource
  - MessageSource의 가장 간단한 구현체로 기본적인 국제화를 지원하면 테스트 용도로 만들어짐.

### ReentrantLock
synchronized를 쓸때하고 ReentrantLock... 뭐가 다르죠?
일단 synchronized에 비해서 ReentrantLock이 훨씬 세부적으로 동기화가 가능합니다.
그리고 가장 큰 차이점은 synchronized는 암묵적이고, ReentrantLock은 명시적이라는 것이죠.
모든 메소드가 명시적으로 표현되어 있고, 그로인해서 사용하는 것도 명시적으로 사용됩
출처: https://eskeptor.tistory.com/83 [Hello World]


### PropertySourcesPlaceholderConfigurer
Spring 3.1 이전 버전에서는 property를 강력하고 유연하게 사용하기 어려웠지만,
이후 new Environment 와 추상화된 PropertySource 덕분에 보다 쉽게 사용할 수 있다.
다수의 property-placeholder를 선언할 경우 order속성을 지정하여 스프링에 의해 처리되는 순서를 지정할 필요가 있다.
또한 마지막 속성을 제외한 모든 속성의 순서를 지정하고 ignore-unresolvable="true"를 함께 작성해야만 예외를 던지지 않는다.
출처 : https://jinyoung8806.github.io/spring/spring_properties/


